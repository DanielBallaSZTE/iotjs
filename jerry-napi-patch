diff --git a/jerry-ext/CMakeLists.txt b/jerry-ext/CMakeLists.txt
index bf1d269..6c5e82e 100644
--- a/jerry-ext/CMakeLists.txt
+++ b/jerry-ext/CMakeLists.txt
@@ -38,6 +38,7 @@ file(GLOB SOURCE_EXT
      common/*.c
      debugger/*.c
      handler/*.c
+     handle-scope/*.c
      module/*.c)
 
 add_library(${JERRY_EXT_NAME} ${SOURCE_EXT})
diff --git a/jerry-ext/handle-scope/handle-scope-allocator.c b/jerry-ext/handle-scope/handle-scope-allocator.c
new file mode 100644
index 0000000..25c8a7b
--- /dev/null
+++ b/jerry-ext/handle-scope/handle-scope-allocator.c
@@ -0,0 +1,222 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include "handle-scope-internal.h"
+
+static jerryx_handle_scope_t kJerryXHandleScopeRoot = {
+  .handle_count = 0,
+  .handle_ptr = NULL,
+};
+static jerryx_handle_scope_t *kJerryXHandleScopeCurrent = &kJerryXHandleScopeRoot;
+static jerryx_handle_scope_pool_t kJerryXHandleScopePool = {
+  .count = 0,
+  .start = NULL,
+};
+
+#define kJerryXHandleScopePoolPrelistLast \
+  kJerryXHandleScopePool.prelist + JERRYX_SCOPE_PRELIST_SIZE - 1
+
+#define JerryXHandleScopePrelistIdx(scope) (scope - kJerryXHandleScopePool.prelist)
+
+
+/**
+ * Get current handle scope top of stack.
+ */
+inline
+jerryx_handle_scope_t *
+jerryx_handle_scope_get_current (void)
+{
+  return kJerryXHandleScopeCurrent;
+}
+
+
+/**
+ * Get root handle scope.
+ */
+inline
+jerryx_handle_scope_t *
+jerryx_handle_scope_get_root (void)
+{
+  return &kJerryXHandleScopeRoot;
+}
+
+
+/**
+ * Determines if given handle scope is located in pre-allocated list.
+ */
+static
+inline
+bool
+jerryx_handle_scope_is_in_prelist (jerryx_handle_scope_t *scope)
+{
+  return (kJerryXHandleScopePool.prelist <= scope) &&
+    (scope <= (kJerryXHandleScopePool.prelist + JERRYX_SCOPE_PRELIST_SIZE - 1));
+}
+
+
+/**
+ * Get the parent of given handle scope.
+ * If given handle scope is in prelist, the parent must be in prelist too;
+ * if given is the first item of heap chain list, the parent must be the last one of prelist;
+ * the parent must be in chain list otherwise.
+ */
+jerryx_handle_scope_t *
+jerryx_handle_scope_get_parent (jerryx_handle_scope_t *scope)
+{
+  if (scope == &kJerryXHandleScopeRoot)
+  {
+    return NULL;
+  }
+  if (!jerryx_handle_scope_is_in_prelist (scope))
+  {
+    jerryx_handle_scope_dynamic_t *dy_scope = (jerryx_handle_scope_dynamic_t *) scope;
+    if (dy_scope == kJerryXHandleScopePool.start)
+    {
+      return kJerryXHandleScopePoolPrelistLast;
+    }
+    jerryx_handle_scope_dynamic_t *parent = dy_scope->parent;
+    return (jerryx_handle_scope_t *) parent;
+  }
+  if (scope == kJerryXHandleScopePool.prelist)
+  {
+    return &kJerryXHandleScopeRoot;
+  }
+  return kJerryXHandleScopePool.prelist + JerryXHandleScopePrelistIdx (scope) - 1;
+}
+
+
+/**
+ * Get the child of given handle scope.
+ * If the given handle scope is in heap chain list, its child must be in heap chain list too;
+ * if the given handle scope is the last one of prelist, its child must be the first item of chain list;
+ * the children are in prelist otherwise.
+ */
+jerryx_handle_scope_t *
+jerryx_handle_scope_get_child (jerryx_handle_scope_t *scope)
+{
+  if (scope == &kJerryXHandleScopeRoot)
+  {
+    if (kJerryXHandleScopePool.count > 0) {
+      return kJerryXHandleScopePool.prelist;
+    }
+    return NULL;
+  }
+  if (!jerryx_handle_scope_is_in_prelist (scope))
+  {
+    jerryx_handle_scope_dynamic_t *child = ((jerryx_handle_scope_dynamic_t *) scope)->child;
+    return (jerryx_handle_scope_t *) child;
+  }
+  if (scope == kJerryXHandleScopePoolPrelistLast)
+  {
+    return (jerryx_handle_scope_t *) kJerryXHandleScopePool.start;
+  }
+  long idx = JerryXHandleScopePrelistIdx (scope);
+  if (idx < 0)
+  {
+    return NULL;
+  }
+  if ((unsigned long) idx >= kJerryXHandleScopePool.count - 1)
+  {
+    return NULL;
+  }
+  return kJerryXHandleScopePool.prelist + idx + 1;
+}
+
+
+/**
+ * Claims a handle scope either from prelist or allocating a new memory block,
+ * and increment pool's scope count by 1, and set current scope to the newly claimed one.
+ * If there are still available spaces in prelist, claims a block in prelist;
+ * otherwise allocates a new memory block from heap and sets its fields to default values,
+ * and link it to previously dynamically allocated scope, or link it to pool's start pointer.
+ *
+ * @returns the newly claimed handle scope pointer.
+ */
+jerryx_handle_scope_t *
+jerryx_handle_scope_alloc (void)
+{
+  jerryx_handle_scope_t *scope;
+  if (kJerryXHandleScopePool.count < JERRYX_SCOPE_PRELIST_SIZE)
+  {
+    scope = kJerryXHandleScopePool.prelist + kJerryXHandleScopePool.count;
+    goto deferred;
+  }
+
+  do {
+    jerryx_handle_scope_dynamic_t *dy_scope = malloc (sizeof(jerryx_handle_scope_dynamic_t));
+    JERRYX_HANDLE_SCOPE_ASSERT(dy_scope != NULL);
+    dy_scope->child = NULL;
+
+    if (kJerryXHandleScopePool.count != JERRYX_SCOPE_PRELIST_SIZE)
+    {
+      jerryx_handle_scope_dynamic_t *dy_current = (jerryx_handle_scope_dynamic_t *) kJerryXHandleScopeCurrent;
+      dy_scope->parent = dy_current;
+      dy_current->child = dy_scope;
+    }
+    else
+    {
+      kJerryXHandleScopePool.start = dy_scope;
+      dy_scope->parent = NULL;
+    }
+
+    scope = (jerryx_handle_scope_t *) dy_scope;
+  } while (0);
+
+deferred:
+  scope->handle_count = 0;
+  scope->escaped = false;
+  scope->handle_ptr = NULL;
+
+  kJerryXHandleScopeCurrent = scope;
+  kJerryXHandleScopePool.count += 1;
+  return (jerryx_handle_scope_t *) scope;
+}
+
+
+/**
+ * Deannounce a previously claimed handle scope, return it to pool
+ * or free the allocated memory block.
+ */
+void
+jerryx_handle_scope_free (jerryx_handle_scope_t *scope)
+{
+  if (scope == &kJerryXHandleScopeRoot)
+  {
+    return;
+  }
+
+  kJerryXHandleScopePool.count -= 1;
+  if (scope == kJerryXHandleScopeCurrent) {
+    kJerryXHandleScopeCurrent = jerryx_handle_scope_get_parent(scope);
+  }
+
+  if (!jerryx_handle_scope_is_in_prelist (scope))
+  {
+    jerryx_handle_scope_dynamic_t *dy_scope = (jerryx_handle_scope_dynamic_t *) scope;
+    if (dy_scope == kJerryXHandleScopePool.start)
+    {
+      kJerryXHandleScopePool.start = dy_scope->child;
+    }
+    else if (dy_scope->parent != NULL)
+    {
+      dy_scope->parent->child = dy_scope->child;
+    }
+    free (dy_scope);
+    return;
+  }
+  /**
+   * Nothing to do with scopes in prelist
+   */
+}
diff --git a/jerry-ext/handle-scope/handle-scope-internal.h b/jerry-ext/handle-scope/handle-scope-internal.h
new file mode 100644
index 0000000..36a5a2c
--- /dev/null
+++ b/jerry-ext/handle-scope/handle-scope-internal.h
@@ -0,0 +1,87 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef JERRYX_HANDLE_SCOPE_INTERNAL_H
+#define JERRYX_HANDLE_SCOPE_INTERNAL_H
+
+#include "jerryscript.h"
+#include "jerryscript-port.h"
+#include "jerryscript-ext/handle-scope.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+#define JERRYX_HANDLE_SCOPE_ASSERT(x) \
+  do \
+  { \
+    if (!(x)) \
+    { \
+      jerry_port_log (JERRY_LOG_LEVEL_ERROR, \
+                      "JerryXHandleScope: Assertion '%s' failed at %s(%s):%lu.\n", \
+                      #x, \
+                      __FILE__, \
+                      __func__, \
+                      (unsigned long) __LINE__); \
+      jerry_port_fatal (ERR_FAILED_INTERNAL_ASSERTION); \
+    } \
+  } while (0)
+
+/** MARK: - handle-scope-allocator.c */
+/**
+ * A linear allocating memory pool for type jerryx_handle_scope_t,
+ * in which allocated item shall be released in reversed order of allocation
+ */
+typedef struct jerryx_handle_scope_pool_s jerryx_handle_scope_pool_t;
+struct jerryx_handle_scope_pool_s {
+  jerryx_handle_scope_t prelist[JERRYX_SCOPE_PRELIST_SIZE];
+  size_t count;
+  jerryx_handle_scope_dynamic_t *start;
+};
+
+jerryx_handle_scope_t *
+jerryx_handle_scope_get_parent (jerryx_handle_scope_t *scope);
+
+jerryx_handle_scope_t *
+jerryx_handle_scope_get_child (jerryx_handle_scope_t *scope);
+
+jerryx_handle_scope_t *
+jerryx_handle_scope_alloc (void);
+
+void
+jerryx_handle_scope_free (jerryx_handle_scope_t *scope);
+/** MARK: - END handle-scope-allocator.c */
+
+/** MARK: - handle-scope.c */
+void
+jerryx_handle_scope_release_handles (jerryx_handle_scope scope);
+
+jerry_value_t
+jerryx_hand_scope_escape_handle_from_prelist (jerryx_handle_scope scope, size_t idx);
+
+jerry_value_t
+jerryx_handle_scope_add_handle_to (jerryx_handle_t *handle, jerryx_handle_scope scope);
+
+jerryx_handle_scope_status
+jerryx_escape_handle_internal (jerryx_escapable_handle_scope scope,
+                               jerry_value_t escapee,
+                               jerry_value_t *result,
+                               bool should_promote);
+/** MARK: - END handle-scope.c */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* !JERRYX_HANDLE_SCOPE_INTERNAL_H */
diff --git a/jerry-ext/handle-scope/handle-scope.c b/jerry-ext/handle-scope/handle-scope.c
new file mode 100644
index 0000000..f06110c
--- /dev/null
+++ b/jerry-ext/handle-scope/handle-scope.c
@@ -0,0 +1,335 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include "handle-scope-internal.h"
+
+/**
+ * Opens a new handle scope and attach it to current global scope as a child scope.
+ *
+ * @return status code, jerryx_handle_scope_ok if success.
+ */
+jerryx_handle_scope_status
+jerryx_open_handle_scope (jerryx_handle_scope *result)
+{
+  *result = jerryx_handle_scope_alloc ();
+  return jerryx_handle_scope_ok;
+}
+
+
+/**
+ * Release all jerry values attached to given scope
+ */
+void
+jerryx_handle_scope_release_handles (jerryx_handle_scope scope)
+{
+  size_t handle_count = scope->handle_count;
+  if (scope->handle_count > JERRYX_HANDLE_PRELIST_SIZE)
+  {
+    jerryx_handle_t *a_handle = scope->handle_ptr;
+    while (a_handle != NULL)
+    {
+      jerry_release_value (a_handle->jval);
+      jerryx_handle_t *sibling = a_handle->sibling;
+      free (a_handle);
+      a_handle = sibling;
+    }
+    handle_count = JERRYX_HANDLE_PRELIST_SIZE;
+  }
+
+  for (size_t idx = 0; idx < handle_count; idx++)
+  {
+    jerry_release_value (scope->handle_prelist[idx]);
+  }
+  scope->handle_count = 0;
+}
+
+
+/**
+ * Close the scope and its child scopes and release all jerry values that
+ * resides in the scopes.
+ * Scopes must be closed in the reverse order from which they were created.
+ *
+ * @return status code, jerryx_handle_scope_ok if success.
+ */
+jerryx_handle_scope_status
+jerryx_close_handle_scope (jerryx_handle_scope scope)
+{
+  /**
+   * Release all handles related to given scope and its child scopes
+   */
+  jerryx_handle_scope a_scope = scope;
+  do
+  {
+    jerryx_handle_scope_release_handles (a_scope);
+    jerryx_handle_scope child = jerryx_handle_scope_get_child (a_scope);
+    jerryx_handle_scope_free (a_scope);
+    a_scope = child;
+  } while (a_scope != NULL);
+
+  return jerryx_handle_scope_ok;
+}
+
+
+/**
+ * Opens a new handle scope from which one object can be promoted to the outer scope
+ * and attach it to current global scope as a child scope.
+ *
+ * @return status code, jerryx_handle_scope_ok if success.
+ */
+jerryx_handle_scope_status
+jerryx_open_escapable_handle_scope (jerryx_handle_scope *result)
+{
+  return jerryx_open_handle_scope (result);
+}
+
+
+/**
+ * Close the scope and its child scopes and release all jerry values that
+ * resides in the scopes.
+ * Scopes must be closed in the reverse order from which they were created.
+ *
+ * @return status code, jerryx_handle_scope_ok if success.
+ */
+jerryx_handle_scope_status
+jerryx_close_escapable_handle_scope (jerryx_handle_scope scope)
+{
+  return jerryx_close_handle_scope (scope);
+}
+
+
+/**
+ * Escape a jerry value from the scope, yet did not promote it to outer scope.
+ * An assertion of if parent exists shall be made before invoking this function.
+ *
+ * @returns escaped jerry value id
+ */
+jerry_value_t
+jerryx_hand_scope_escape_handle_from_prelist (jerryx_handle_scope scope, size_t idx)
+{
+  jerry_value_t jval = scope->handle_prelist[idx];
+  if (scope->handle_count > JERRYX_HANDLE_PRELIST_SIZE)
+  {
+    jerryx_handle_t *handle = scope->handle_ptr;
+    scope->handle_ptr = handle->sibling;
+    scope->handle_prelist[idx] = handle->jval;
+    return jval;
+  }
+
+  if (idx < JERRYX_HANDLE_PRELIST_SIZE - 1)
+  {
+    scope->handle_prelist[idx] = scope->handle_prelist[scope->handle_count - 1];
+  }
+  return jval;
+}
+
+
+jerryx_handle_scope_status
+jerryx_escape_handle_internal (jerryx_escapable_handle_scope scope,
+                               jerry_value_t escapee,
+                               jerry_value_t *result,
+                               bool should_promote)
+{
+  if (scope->escaped)
+  {
+    return jerryx_escape_called_twice;
+  }
+
+  jerryx_handle_scope parent = jerryx_handle_scope_get_parent (scope);
+  if (parent == NULL)
+  {
+    return jerryx_handle_scope_mismatch;
+  }
+
+  bool found = false;
+  {
+    size_t found_idx = 0;
+    size_t prelist_count =
+      scope->handle_count < JERRYX_HANDLE_PRELIST_SIZE ?
+        scope->handle_count :
+        JERRYX_HANDLE_PRELIST_SIZE;
+    /**
+     * Search prelist in a reversed order since last added handle
+     * is possible the one to be escaped
+     */
+    for (size_t idx_plus_1 = prelist_count; idx_plus_1 > 0; --idx_plus_1)
+    {
+      if (escapee == scope->handle_prelist[idx_plus_1 - 1])
+      {
+        found = true;
+        found_idx = idx_plus_1 - 1;
+        break;
+      }
+    }
+
+    if (found)
+    {
+      *result = jerryx_hand_scope_escape_handle_from_prelist (scope, found_idx);
+      if (should_promote)
+      {
+        /**
+         * Escape handle to parent scope
+         */
+        jerryx_create_handle_in_scope (*result, jerryx_handle_scope_get_parent (scope));
+      }
+      goto deferred;
+    }
+  };
+
+  if (scope->handle_count <= JERRYX_HANDLE_PRELIST_SIZE)
+  {
+    return jerryx_handle_scope_mismatch;
+  }
+
+  /**
+   * Handle chain list is already in an reversed order,
+   * search through it as it is
+   */
+  jerryx_handle_t *handle = scope->handle_ptr;
+  jerryx_handle_t *memo_handle = NULL;
+  jerryx_handle_t *found_handle = NULL;
+  while (!found)
+  {
+    if (handle == NULL)
+    {
+      return jerryx_handle_scope_mismatch;
+    }
+    if (handle->jval != escapee)
+    {
+      memo_handle = handle;
+      handle = handle->sibling;
+      continue;
+    }
+    /**
+     * Remove found handle from current scope's handle chain
+     */
+    found = true;
+    found_handle = handle;
+    if (memo_handle == NULL)
+    {
+      // found handle is the first handle in heap
+      scope->handle_ptr = found_handle->sibling;
+    }
+    else
+    {
+      memo_handle->sibling = found_handle->sibling;
+    }
+  }
+
+  if (should_promote)
+  {
+    /**
+     * Escape handle to parent scope
+     */
+    *result = jerryx_handle_scope_add_handle_to (found_handle, parent);
+  }
+
+deferred:
+  scope->handle_count -= 1;
+  if (should_promote)
+  {
+    scope->escaped = true;
+  }
+  return jerryx_handle_scope_ok;
+}
+
+
+/**
+ * Promotes the handle to the JavaScript object so that it is valid for the lifetime of
+ * the outer scope. It can only be called once per scope. If it is called more than
+ * once an error will be returned.
+ *
+ * @return status code, jerryx_handle_scope_ok if success.
+ */
+jerryx_handle_scope_status
+jerryx_escape_handle (jerryx_escapable_handle_scope scope,
+                      jerry_value_t escapee,
+                      jerry_value_t *result)
+{
+  return jerryx_escape_handle_internal (scope, escapee, result, true);
+}
+
+
+/**
+ * Escape a handle from scope yet do not promote it to the outer scope.
+ * Leave the handle's life time management up to user.
+ *
+ * @return status code, jerryx_handle_scope_ok if success.
+ */
+jerryx_handle_scope_status
+jerryx_remove_handle (jerryx_escapable_handle_scope scope,
+                      jerry_value_t escapee,
+                      jerry_value_t *result)
+{
+  return jerryx_escape_handle_internal (scope, escapee, result, false);
+}
+
+
+/**
+ * Try to reuse given handle if possible while adding to the scope.
+ *
+ * @returns the jerry value id wrapped by given handle.
+ */
+jerry_value_t
+jerryx_handle_scope_add_handle_to (jerryx_handle_t *handle, jerryx_handle_scope scope)
+{
+  size_t handle_count = scope->handle_count;
+  scope->handle_count += 1;
+  if (handle_count < JERRYX_HANDLE_PRELIST_SIZE)
+  {
+    jerry_value_t jval = handle->jval;
+    free (handle);
+    scope->handle_prelist[handle_count] = jval;
+    return jval;
+  }
+
+  handle->sibling = scope->handle_ptr;
+  scope->handle_ptr = handle;
+  return handle->jval;
+}
+
+
+/**
+ * Add given jerry value to the scope.
+ */
+jerry_value_t
+jerryx_create_handle_in_scope (jerry_value_t jval, jerryx_handle_scope scope)
+{
+  size_t handle_count = scope->handle_count;
+  if (handle_count < JERRYX_HANDLE_PRELIST_SIZE)
+  {
+    scope->handle_prelist[handle_count] = jval;
+    goto deferred;
+  }
+  jerryx_handle_t *handle = malloc (sizeof(jerryx_handle_t));
+  JERRYX_HANDLE_SCOPE_ASSERT(handle != NULL);
+  handle->jval = jval;
+
+  handle->sibling = scope->handle_ptr;
+  scope->handle_ptr = handle;
+
+deferred:
+  scope->handle_count += 1;
+  return jval;
+}
+
+
+/**
+ * Add given jerry value to current top scope.
+ */
+jerry_value_t
+jerryx_create_handle (jerry_value_t jval)
+{
+  return jerryx_create_handle_in_scope (jval, jerryx_handle_scope_get_current ());
+}
diff --git a/jerry-ext/include/jerryscript-ext/handle-scope.h b/jerry-ext/include/jerryscript-ext/handle-scope.h
new file mode 100644
index 0000000..3841bc0
--- /dev/null
+++ b/jerry-ext/include/jerryscript-ext/handle-scope.h
@@ -0,0 +1,112 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef JERRYX_HANDLE_SCOPE_H
+#define JERRYX_HANDLE_SCOPE_H
+
+#include "jerryscript.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif /* __cplusplus */
+
+#ifndef JERRYX_HANDLE_PRELIST_SIZE
+#define JERRYX_HANDLE_PRELIST_SIZE 20
+#endif
+
+#ifndef JERRYX_SCOPE_PRELIST_SIZE
+#define JERRYX_SCOPE_PRELIST_SIZE 20
+#endif
+
+typedef struct jerryx_handle_t jerryx_handle_t;
+struct jerryx_handle_t {
+  jerry_value_t jval;
+  jerryx_handle_t *sibling;
+};
+
+#define JERRYX_HANDLE_SCOPE_FIELDS                          \
+  jerry_value_t handle_prelist[JERRYX_HANDLE_PRELIST_SIZE]; \
+  size_t handle_count;                                      \
+  bool escaped;                                             \
+  jerryx_handle_t *handle_ptr
+
+typedef struct jerryx_handle_scope_s jerryx_handle_scope_t;
+typedef jerryx_handle_scope_t *jerryx_handle_scope;
+typedef jerryx_handle_scope_t *jerryx_escapable_handle_scope;
+struct jerryx_handle_scope_s {
+  JERRYX_HANDLE_SCOPE_FIELDS;
+};
+
+
+typedef struct jerryx_handle_scope_dynamic_s jerryx_handle_scope_dynamic_t;
+struct jerryx_handle_scope_dynamic_s {
+  JERRYX_HANDLE_SCOPE_FIELDS;
+  jerryx_handle_scope_dynamic_t *child;
+  jerryx_handle_scope_dynamic_t *parent;
+};
+
+#undef JERRYX_HANDLE_SCOPE_FIELDS
+
+typedef enum {
+  jerryx_handle_scope_ok = 0,
+
+  jerryx_escape_called_twice,
+  jerryx_handle_scope_mismatch,
+} jerryx_handle_scope_status;
+
+jerryx_handle_scope_status
+jerryx_open_handle_scope (jerryx_handle_scope *result);
+
+jerryx_handle_scope_status
+jerryx_close_handle_scope (jerryx_handle_scope scope);
+
+jerryx_handle_scope_status
+jerryx_open_escapable_handle_scope (jerryx_handle_scope *result);
+
+jerryx_handle_scope_status
+jerryx_close_escapable_handle_scope (jerryx_handle_scope scope);
+
+jerryx_handle_scope_status
+jerryx_escape_handle (jerryx_escapable_handle_scope scope,
+                      jerry_value_t escapee,
+                      jerry_value_t *result);
+
+/**
+ * Completely escape a handle from handle scope,
+ * leave life time management totally up to user.
+ */
+jerryx_handle_scope_status
+jerryx_remove_handle (jerryx_escapable_handle_scope scope,
+                      jerry_value_t escapee,
+                      jerry_value_t *result);
+
+jerry_value_t
+jerryx_create_handle (jerry_value_t jval);
+
+jerry_value_t
+jerryx_create_handle_in_scope (jerry_value_t jval, jerryx_handle_scope scope);
+
+/** MARK: - handle-scope-allocator.c */
+jerryx_handle_scope_t *
+jerryx_handle_scope_get_current (void);
+
+jerryx_handle_scope_t *
+jerryx_handle_scope_get_root (void);
+/** MARK: - END handle-scope-allocator.c */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* !JERRYX_HANDLE_SCOPE_H */
